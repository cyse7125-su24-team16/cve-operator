package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/go-logr/logr"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	webappv1 "cyse7125-su24-team16/cve-operator/api/v1"
)

type GitHubReleasesMonitorReconciler struct {
	client.Client
	Log    logr.Logger
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=webapp.cyse7125-su24-team16,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=webapp.cyse7125-su24-team16,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=webapp.cyse7125-su24-team16,resources=githubreleasesmonitors/finalizers,verbs=update
// +kubebuilder:rbac:groups=webapp.cyse7125-su24-team16,resources=githubreleases,verbs=get;list;watch;create;update;patch;delete

func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	monitor := &webappv1.GitHubReleasesMonitor{}
	err := r.Get(ctx, req.NamespacedName, monitor)
	if err != nil {
		if errors.IsNotFound(err) {
			return ctrl.Result{}, nil
		}
		return ctrl.Result{}, err
	}

	logger.Info("Successfully fetched GitHubReleasesMonitor", "monitor", monitor)

	// Update monitor status first
	err = r.updateMonitorStatus(ctx, monitor)
	if err != nil {
		logger.Error(err, "Failed to update monitor status")
		return ctrl.Result{}, err
	}

	// After updating the status, now we can check for deleted releases
	var validReleases []string
	for _, releaseName := range monitor.Status.Releases {
		if r.releaseExists(ctx, monitor.Namespace, releaseName) {
			validReleases = append(validReleases, releaseName)
		} else {
			logger.Info("Removing deleted release from status", "Release", releaseName)
		}
	}

	if len(validReleases) != len(monitor.Status.Releases) {
		monitor.Status.Releases = validReleases
		if err := r.Status().Update(ctx, monitor); err != nil {
			logger.Error(err, "Failed to update GitHubReleasesMonitor status")
			return ctrl.Result{}, err
		}
	}

	return ctrl.Result{RequeueAfter: 3 * time.Minute}, nil
}

func (r *GitHubReleasesMonitorReconciler) updateMonitorStatus(ctx context.Context, monitor *webappv1.GitHubReleasesMonitor) error {
	releases, err := fetchReleases(monitor.Spec.URL)
	if err != nil {
		return err
	}

	logger := log.FromContext(ctx)
	logger.Info("Successfully fetched releases", "releases", releases)

	var monitorFromTime time.Time
	if monitor.Spec.MonitorFrom == "now" {
		monitorFromTime = monitor.CreationTimestamp.Time
	} else {
		monitorFromTime, err = parseTime(monitor.Spec.MonitorFrom)
		if err != nil {
			return err
		}
	}

	logger.Info("Monitor from time determined", "monitorFromTime", monitorFromTime)

	var newReleases []string
	for _, release := range releases {
		releaseTime, err := time.Parse(time.RFC3339, release.CreatedAt)
		if err != nil {
			logger.Error(err, "Failed to parse release time", "release", release)
			continue
		}
		if releaseTime.After(monitorFromTime) && !contains(monitor.Status.Releases, release.TagName) {
			err := r.createOrUpdateGitHubRelease(ctx, monitor.Namespace, release)
			if err != nil {
				logger.Error(err, "Failed to create or update GitHubRelease", "release", release)
				continue
			}
			newReleases = append(newReleases, release.TagName)
		}
	}

	logger.Info("New releases processed", "newReleases", newReleases)

	monitor.Status.Releases = append(monitor.Status.Releases, newReleases...)
	monitor.Status.LastChecked = metav1.Time{Time: time.Now().UTC()}
	monitor.Status.MonitorFromTimestamp = metav1.Time{Time: monitorFromTime}
	monitor.Status.Recreated = false
	return r.Status().Update(ctx, monitor)
}

func (r *GitHubReleasesMonitorReconciler) createOrUpdateGitHubRelease(ctx context.Context, namespace string, release webappv1.Release) error {
	sanitizedReleaseName := sanitizeName(release.TagName)

	existingRelease := &webappv1.GitHubRelease{}
	err := r.Get(ctx, client.ObjectKey{Name: sanitizedReleaseName, Namespace: namespace}, existingRelease)
	if err != nil && !errors.IsNotFound(err) {
		return err
	}

	if errors.IsNotFound(err) || !existingRelease.ObjectMeta.DeletionTimestamp.IsZero() {
		// Recreate the GitHubRelease CR
		logger := log.FromContext(ctx)
		if !existingRelease.ObjectMeta.DeletionTimestamp.IsZero() {
			logger.Info("GitHubRelease is marked for deletion. Removing finalizer and recreating.", "release", sanitizedReleaseName)
			existingRelease.ObjectMeta.Finalizers = removeString(existingRelease.ObjectMeta.Finalizers, finalizerName)
			if err := r.Update(ctx, existingRelease); err != nil {
				return err
			}
		}

		logger.Info("GitHubRelease not found or marked for deletion. Creating a new one.", "release", sanitizedReleaseName)
		newReleaseCR := &webappv1.GitHubRelease{
			ObjectMeta: metav1.ObjectMeta{
				Name:      sanitizedReleaseName,
				Namespace: namespace,
			},
			Spec: webappv1.GitHubReleaseSpec{
				TagName:        release.TagName,
				ReleaseURL:     release.URL,
				ReleaseDetails: release,
			},
			Status: webappv1.GitHubReleaseStatus{
				Processed: false,
			},
		}
		return r.Create(ctx, newReleaseCR)
	}

	return nil
}

func sanitizeName(name string) string {
	name = strings.ToLower(name)
	invalidChars := regexp.MustCompile(`[^a-z0-9-]+`)
	name = invalidChars.ReplaceAllString(name, "-")
	name = strings.Trim(name, "-")
	return name
}

var (
	releasesCache    map[string][]webappv1.Release
	releasesCacheMux sync.RWMutex
	lastFetchTime    map[string]time.Time
	lastFetchTimeMux sync.RWMutex
	etagCache        map[string]string
	etagCacheMux     sync.RWMutex
)

func init() {
	releasesCache = make(map[string][]webappv1.Release)
	lastFetchTime = make(map[string]time.Time)
	etagCache = make(map[string]string)
}

func fetchReleases(url string) ([]webappv1.Release, error) {
	releasesCacheMux.RLock()
	cachedReleases, found := releasesCache[url]
	releasesCacheMux.RUnlock()

	lastFetchTimeMux.RLock()
	lastFetch, _ := lastFetchTime[url]
	lastFetchTimeMux.RUnlock()

	if found && time.Since(lastFetch) < 15*time.Minute {
		return cachedReleases, nil
	}

	etagCacheMux.RLock()
	etag := etagCache[url]
	etagCacheMux.RUnlock()

	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	if etag != "" {
		req.Header.Set("If-None-Match", etag)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotModified {
		return cachedReleases, nil
	}

	if resp.StatusCode != http.StatusOK {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to fetch releases: %s", string(bodyBytes))
	}

	var releases []webappv1.Release
	err = json.NewDecoder(resp.Body).Decode(&releases)
	if err != nil {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to parse JSON response: %s", string(bodyBytes))
	}

	releasesCacheMux.Lock()
	releasesCache[url] = releases
	releasesCacheMux.Unlock()

	lastFetchTimeMux.Lock()
	lastFetchTime[url] = time.Now()
	lastFetchTimeMux.Unlock()

	etagCacheMux.Lock()
	etagCache[url] = resp.Header.Get("ETag")
	etagCacheMux.Unlock()

	return releases, nil
}

func parseTime(t string) (time.Time, error) {
	return time.Parse(time.RFC3339, t)
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func removeString(slice []string, s string) []string {
	var result []string
	for _, item := range slice {
		if item != s {
			result = append(result, item)
		}
	}
	return result
}

func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&webappv1.GitHubReleasesMonitor{}).
		Complete(r)
}

func (r *GitHubReleasesMonitorReconciler) releaseExists(ctx context.Context, namespace, releaseName string) bool {
	releaseCR := &webappv1.GitHubRelease{}
	err := r.Get(ctx, client.ObjectKey{Namespace: namespace, Name: releaseName}, releaseCR)
	return !errors.IsNotFound(err)
}
