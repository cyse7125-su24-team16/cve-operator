package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/go-logr/logr"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	webappv1 "cyse7125-su24-team16/cve-operator/api/v1" // Import the correct package
)

type GitHubReleasesMonitorReconciler struct {
	client.Client
	Log    logr.Logger
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=webapp.cyse7125-su24-team16,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=webapp.cyse7125-su24-team16,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=webapp.cyse7125-su24-team16,resources=githubreleasesmonitors/finalizers,verbs=update

func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	monitor := &webappv1.GitHubReleasesMonitor{}
	err := r.Get(ctx, req.NamespacedName, monitor)
	if err != nil {
		if errors.IsNotFound(err) {
			return ctrl.Result{}, nil
		}
		return ctrl.Result{}, err
	}

	logger.Info("Successfully fetched GitHubReleasesMonitor", "monitor", monitor)

	releases, err := fetchReleases(monitor.Spec.URL)
	if err != nil {
		logger.Error(err, "Failed to fetch releases from GitHub")
		return ctrl.Result{}, err
	}

	logger.Info("Successfully fetched releases", "releases", releases)

	var monitorFromTime time.Time
	if monitor.Spec.MonitorFrom == "now" {
		monitorFromTime = monitor.CreationTimestamp.Time
	} else {
		monitorFromTime, err = parseTime(monitor.Spec.MonitorFrom)
		if err != nil {
			logger.Error(err, "Failed to parse monitorFrom time")
			return ctrl.Result{}, err
		}
	}

	logger.Info("Monitor from time determined", "monitorFromTime", monitorFromTime)

	var newReleases []string
	for _, release := range releases {
		releaseTime, err := time.Parse(time.RFC3339, release.CreatedAt)
		if err != nil {
			logger.Error(err, "Failed to parse release time", "release", release)
			continue
		}
		if releaseTime.After(monitorFromTime) && !contains(monitor.Status.Releases, release.TagName) {
			err := r.createGitHubRelease(ctx, monitor.Namespace, release)
			if err != nil {
				logger.Error(err, "Failed to create GitHubRelease", "release", release)
				continue
			}
			newReleases = append(newReleases, release.TagName)
		}
	}

	logger.Info("New releases processed", "newReleases", newReleases)

	monitor.Status.Releases = append(monitor.Status.Releases, newReleases...)
	monitor.Status.LastChecked = metav1.Time{Time: time.Now().UTC()}
	monitor.Status.MonitorFromTimestamp = metav1.Time{Time: monitorFromTime}
	err = r.Status().Update(ctx, monitor)
	if err != nil {
		logger.Error(err, "Failed to update GitHubReleasesMonitor status")
		return ctrl.Result{}, err
	}

	logger.Info("GitHubReleasesMonitor status updated", "status", monitor.Status)

	return ctrl.Result{RequeueAfter: time.Hour}, nil
}

func (r *GitHubReleasesMonitorReconciler) createGitHubRelease(ctx context.Context, namespace string, release webappv1.Release) error {
	// Sanitize the release.TagName to conform to Kubernetes naming conventions
	sanitizedReleaseName := sanitizeName(release.TagName)

	releaseCR := &webappv1.GitHubRelease{
		ObjectMeta: metav1.ObjectMeta{
			Name:      sanitizedReleaseName,
			Namespace: namespace,
		},
		Spec: webappv1.GitHubReleaseSpec{
			TagName:        release.TagName,
			ReleaseURL:     release.URL,
			ReleaseDetails: release,
		},
		Status: webappv1.GitHubReleaseStatus{
			Processed: false,
		},
	}
	return r.Create(ctx, releaseCR)
}

// sanitizeName ensures the name conforms to Kubernetes naming conventions
func sanitizeName(name string) string {
	// Convert to lower case
	name = strings.ToLower(name)
	// Replace invalid characters with '-'
	invalidChars := regexp.MustCompile(`[^a-z0-9-]+`)
	name = invalidChars.ReplaceAllString(name, "-")
	// Ensure the name starts and ends with an alphanumeric character
	name = strings.Trim(name, "-")
	return name
}

func fetchReleases(url string) ([]webappv1.Release, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to fetch releases: %s", string(bodyBytes))
	}

	var releases []webappv1.Release
	err = json.NewDecoder(resp.Body).Decode(&releases)
	if err != nil {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to parse JSON response: %s", string(bodyBytes))
	}

	return releases, nil
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&webappv1.GitHubReleasesMonitor{}).
		Complete(r)
}

func parseTime(timeStr string) (time.Time, error) {
	if t, err := time.Parse(time.RFC3339, timeStr); err == nil {
		return t, nil
	}
	if t, err := time.Parse("2006-01-02", timeStr); err == nil {
		return t, nil
	}
	return time.Time{}, fmt.Errorf("unsupported time format: %s", timeStr)
}
